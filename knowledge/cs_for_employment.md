# CHAPTER 02 - 컴퓨터 구조

## RAM과 하드 디스크의 차이를 설명해 보세요.

RAM이 CPU가 실행할 프로그램을 저장하는 부품이라면, 하드 디스크는 전원이 꺼져도 보관할 대상을 저장하는 부품입니다. 휘발성 저장장치인 RAM은 전원이 꺼지면 저장된 내용을 잃지만, 하드 디스크는 비휘발성 저장장치이기 때문에 전원이 꺼져도 저장된 내용을 잃지 않는다는 차이가 있습니다.

## 병렬성과 동시성, 두 개념의 차이를 예시와 함께 설명해 보세요.

병렬성은 작업을 실제로 같은 시각에 동시 처리하는 성질을 의미하고, 동시성은 작업을 동시에 처리하는 것처럼 보이는 성질을 의미합니다. 멀티코어 CPU의 여러 코어가 같은 시각에 명령어를 동시에 처리하는 것이 병렬성의 예시이고, 1코어 1스레드 CPU가 여러 작업을 빠르게 번갈아 가며 처리하는 것이 동시성의 예시입니다.

## CPU가 자발적으로 발생시키는 인터럽트와 CPU가 받아들이는 인터럽트의 차이가 무엇인지 설명해 보세요.

CPU가 자발적으로 발생시키는 인터럽트는 동기적인 인터럽트로, CPU가 프로그래밍 오류와 같은 예외적으로 예상치 못한 상황을 마주쳤을 때 주로 발생하는 인터럽트입니다. 반면, CPU가 받아들이는 인터럽트는 비동기적인 인터럽트로, 주로 입출력장치로부터 받아들이는 하드웨어 인터럽트를 말합니다.

## 다음 소스 코드의 결과는 모두 '3.000...4'입니다. 그 이유를 설명해 보세요.

```python
print(0.1 + 0.2)
```

```java
System.out.println(0.1 + 0.2);
```

```javascript
console.log(0.1 + 0.2);
```

컴퓨터는 내부적으로 부동 소수점 방식을 통해 소수를 표현합니다. 부동 소수점 방식은 2진수로 소수를 표현하는 방법으로, '가수×2^지수'의 형태를 띱니다. 소스 코드에 제시된 '0.1'과 '0.2'는 10진수 소수로, '가수×10^지수'의 형태로 표현할 수 있지만, 이를 부동 소수점 방식의 2진수로 표현하면 무한 소수가 됩니다. 무한 소수에 무한 소수를 더한 결과를 10진수 소수로 표현하다 보니 오차가 발생한 것입니다.

## 다음 소스 코드에는 성능상의 문제가 있습니다. 어떤 문제인지 설명해 보세요.

```java
public class Main {
    public static void main(String[] args) {
        int[][] matrix = new int[20000][20000];

        for (int i = 0; i < 20000; i++) {
            for (int j = 0; j < 20000; j++) {
                matrix[j][i] = 1;
            }
        }
    }
}
```

주어진 소스 코드 중 배열에 접근하는 `matrix[j][i] = 1;` 부분은 캐시 친화적이지 않기 때문에 성능상의 문제가 될 수 있습니다. 배열이 저장된 위치에 순차적으로 접근하지 않기 때문에 성능 저하를 가져오게 됩니다. 이차원 배열이 메모리에 저장된 순서에 따라 접근하도록 코드를 수정하면 프로그램의 속도를 개선할 수 있습니다.

## 장치 드라이버는 왜 설치해야 하나요?

CPU가 장치 컨트롤러를 작동시키기 위한 정보를 알아야 하기 때문입니다. CPU는 장치 드라이버가 설치되어 있지 않으면 해당 입출력장치를 어떻게 작동시켜야 할지, 즉 장치 컨트롤러와 어떻게 정보를 주고받아야 하는지 알 수가 없습니다.

## 파이프라이닝이란 무엇이며, 어떻게 CPU의 성능을 향상시키는지 설명해 보세요.

파이프라이닝이란 명령어 병렬 처리 기법 중 하나로, 하나의 명령어를 처리하는 과정을 비슷한 시간 간격으로 쪼갠 뒤, 쪼개진 각각의 단계에서 동시에 실행 가능한 단계를 겹쳐서 실행해 CPU의 처리 성능을 높입니다.

## GPU와 CPU를 비교하여 설명해 보세요.

GPU는 주로 산술 연산과 같이 단순 연산을 병렬적으로 수행하기 위한 장치이고, CPU는 범용적인 연산을 수행하기 위한 장치입니다. GPU는 병렬 처리를 위한 코어가 수백에서 수천 개까지 포함되어 있지만, CPU처럼 코어마다 복잡한 연산을 지원하지는 않습니다.

## `base64` 인코딩이란 무엇이며, 어디에서 `base64` 인코딩을 사용하는지 설명해 보세요.

`base64` 인코딩은 문자뿐만 아니라 아스키 코드로 표현할 수 없는 이미지 등의 이진 데이터까지 아스키 형태의 문자로 표현하기 위해 사용하는 인코딩 방식입니다. 주로 이메일에서 첨부파일을 전송하거나 웹에서 이미지 및 파일 데이터를 텍스트 형식으로 포함할 때 사용합니다.

## 동일한 소스 코드라 하더라도 애플 M1 컴퓨터에서 컴파일해 만든 실행 파일을 인텔 x86 컴퓨터로 옮겨 실행할 수 없는 이유를 설명해 보세요.

동일한 소스 코드라도 각기 다른 명령어로 변환될 수 있기 때문입니다. 실행 파일은 각각의 컴퓨터가 이해할 수 있는 명령어의 모음이기 때문에 CPU마다 이해하는 명령어의 집합이 다릅니다. 따라서 실행할 수 있는 실행 파일도 달라집니다. 이런 이유로 애플 M1 컴퓨터에서 컴파일해 만든 실행 파일을 인텔 x86 컴퓨터로 옮겨서 실행하면 실행이 되지 않는 것입니다.

## 하드웨어적 스레드와 소프트웨어적 스레드의 차이에 대해 설명해 보세요.

하드웨어 스레드는 하나의 코어가 동시에 처리하는 명령어의 단위를 의미합니다. 논리 프로세서라고도 부릅니다. 소프트웨어 스레드란 하나의 프로그램에서 독립적으로 실행되는 단위를 의미합니다. 따라서 1코어 1스레드 CPU에서도 여러 소프트웨어 스레드를 빠르게 번걸아가며 실행할 수 있습니다.

## 코딩을 하다가 한글이 깨지면 어떻게 대처해야 할까요?

한글이 깨지는 경우는 컴퓨터가 이해할 수 있는 문자의 모음, 문자 집합을 인식하지 못했거나 문자 집합을 코드로 표현하는 인코딩 방법을 인식하지 못한 경우입니다. 따라서 다른 문자 집합을 지원하는 다양한 인코딩 방법을 시도해 봐야 합니다.

## PCIe란 무엇이며, PCIe가 연결 부품의 성능과 어떤 연관이 있는지 설명해 보세요.

PCIe란 대표적인 입출력 버스의 일종으로, 버전에 따라 지원되는 최대 속도(대역폭)
이 다르므로 연결되는 부품의 성능에 영향을 끼칠 수 있습니다. PCIe 3.0의 최대 지원 속도는 PCIe 6.0의 최대 지원 속도에 비해 느리기 때문에 같은 부품이라 하더라도 PCIe 3.0에 연결할 경우 입출력 버스의 최대 지원 속도가 더 느릴 수 있습니다.

## 캐시 미스란 무엇이며, 캐시 미스가 프로그램의 성능에 어떤 영향을 끼치는지 설명해 보세요.

캐시 미스란 캐시에 있을 것이라고 기대했던 데이터가 캐시에 존재하지 않는 상황을 의미합니다. 캐시 미스가 발생하면 캐시를 활용할 수 없고, 메모리와 같이 실제로 데이터가 위치하고 있는 먼 곳까지 접근해야 합니다. 따라서 프로그램의 성능에 악영향을 끼치게 됩니다.

## 유니코드란 무엇인지 설명해 보세요.

여러 국가의 언어나 이모티콘 등을 표현할 수 있는 통일된 문자 집합을 말합니다. 유니코드마다 부여되어 있는 고유한 수, 코드 포인트를 어떻게 코드로 표현하는지에 따라 `utf-8`, `utf-16`, `utf-32` 등 다양한 인코딩 방법으로 구분할 수 있습니다.

# CHAPTER 03 - 운영체제

## 다음 코드에는 문제가 있습니다. 어떤 문제가 있는지 설명해 보세요.

```c
#include <stdio.h>
#include <pthread.h>

int shared_data = 0;  // 공유 데이터

void* increment(void* arg) {
    int i;
    for (i = 0; i < 100000; i++) {
        shared_data++;  // 공유 데이터 증가
    }
    return NULL;
}

void* decrement(void* arg) {
    int i;
    for (i = 0; i < 100000; i++) {
        shared_data--;  // 공유 데이터 감소
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;

    pthread_create(&thread1, NULL, increment, NULL);
    pthread_create(&thread2, NULL, decrement, NULL);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    printf("Final value of shared_data: %d\n", shared_data);

    return 0;
}
```

공유 데이터인 `shared_data`가 두 스레드에서 동시에 수정되는 과정에서 발생할 수 있는 레이스 컨디션 문제가 있습니다. `shared_data++`와 `shared_data--`라는 임계 구역에서의 연산이 하나씩만 수행되지 않기 때문에 데이터의 일관성이 보장되지 않을 수 있습니다.

## 직전 문제에서 제시한 코드의 문제를 해결해 보세요.

문제를 해결하려면 mutex 등을 활용해 공유 자원에 대한 접근을 동기화해야 합니다. 다음과 같은 코드를 추가하면 임계 구역을 보호할 수 있습니다.

```c
#include <stdio.h>
#include <pthread.h>

int shared_data = 0;  // 공유 데이터
pthread_mutex_t mutex;  // 뮤텍스 선언

void* increment(void* arg) {
    int i;
    for (i = 0; i < 100000; i++) {
        pthread_mutex_lock(&mutex);  // 뮤텍스 락 획득
        shared_data++;  // 공유 데이터 증가
        pthread_mutex_unlock(&mutex);  // 뮤텍스 언락
    }
    return NULL;
}

void* decrement(void* arg) {
    int i;
    for (i = 0; i < 100000; i++) {
        pthread_mutex_lock(&mutex);  // 뮤텍스 락 획득
        shared_data--;  // 공유 데이터 감소
        pthread_mutex_unlock(&mutex);  // 뮤텍스 언락
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;

    pthread_mutex_init(&mutex, NULL);  // 뮤텍스 초기화

    pthread_create(&thread1, NULL, increment, NULL);
    pthread_create(&thread2, NULL, decrement, NULL);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    printf("Final value of shared_data: %d\n", shared_data);

    pthread_mutex_destroy(&mutex);  // 뮤텍스 해제

    return 0;
}
```

## 공유 메모리 기반 IPC가 소켓 통신보다 빠른 이유를 설명해 보세요.

공유 메모리는 동일한 메모리 공간에 직접 접근하여 데이터를 주고받고, 마치 자신의 메모리 공간을 읽고 쓰는 것처럼 IPC가 이루어지기 때문에 빠릅니다. 이에 반해 소켓 통신은 주고받는 데이터가 커널을 통하므로 추가적인 오버헤드가 발생할 수 있어, 공유 메모리 기반 IPC보다 다소 느릴 수 있습니다.

## 운영체제가 메모리에 적재되기까지의 과정을 설명해 보세요(부팅의 과정을 설명해 보세요).

컴퓨터 전원이 켜지면 CPU는 ROM에 저장된 BIOS를 실행합니다. BIOS는 하드웨어를 검사하는 POST 수행 후, 하드 디스크의 MBR을 읽어 부트 로더를 로드합니다. 부트 로더가 커널의 위치를 찾아 RAM에 적재함으로써 커널이 메모리에 로드됩니다.

## 운영체제의 커널이 무엇이며, 커널이 왜 존재하는지에 대해 설명해 보세요.

커널은 운영체제의 핵심 부분으로, 컴퓨터 하드웨어와 응용 프로그램 간의 중재자 역할을 합니다. 커널은 프로세스와 스레드가 올바르게 실행되도록 돕고, 이들이 CPU, 메모리, 보조기억장치 등의 하드웨어를 공정하게 할당받아 실행되도록 합니다. 또 커널은 이중 모드를 운영해 사용자 응용 프로그램이 안전하고 효율적으로 시스템 자원을 사용할 수 있도록 합니다.

## 스레드 안전하지 않은 메서드를 동기화하지 않으면 어떤 문제가 생길 수 있나요?

여러 스레드가 동시에 실행될 경우 레이스 컨디션이 발생하여 데이터의 일관성이 깨질 수 있습니다. 따라서 추가적인 동기화 도구를 적용하거나, 스레드 안전한 메서드를 사용해야 합니다.

## 리눅스 운영체제에서 일반적인 사용자 프로세스가 어떻게 CPU를 할당받아 실행되는지 설명해 보세요.

리눅스에서 일반적인 사용자 프로세스는 CFS 스케줄러에 의해 스케줄링됩니다. CFS 스케줄러는 각 프로세스에 CPU의 시간을 공평하게 배분하는 것을 목표로 합니다. 기본적으로 각 프로세스의 가상 실행 시간인 `vruntime`을 유지하며, `vruntime`이 가장 작은 프로세스부터 스케줄링합니다. 프로세스의 `vruntime`은 실제 실행 시간에 프로세스의 우선순위에 따른 가중치를 고려하여 계산되며, 우선순위가 높을수록 `vruntime`의 증가가 느려지기 때문에 우선순위가 높은 프로세스는 더 자주 CPU를 할당받게 됩니다.

## 지나치게 문맥 교환이 반복되면 어떤 문제가 발생할 수 있나요?

빈번한 문맥 교환은 실제 작업보다 문맥 저장과 복구에 CPU 시간을 사용하게 되므로 효율성을 떨어뜨립니다. 또한 캐시 메모리의 데이터를 반복적으로 무효화하게 되므로 캐시 미스율이 증가하고, 캐시 미스와 문맥 교환 오버헤드로 인한 전체 시스템의 처리 속도가 저하될 수 있습니다.

## 4GB보다 큰 크기의 프로그램을 4GB인 물리 메모리로 실행할 수 있을까요? 실행할 수 있다면 어떻게 가능할까요?

가상 메모리 기술을 통해 가능합니다. 운영체제는 프로세스가 필요한 메모리 공간을 가상 주소로 할당하고, 실제 물리 메모리에는 필요한 부분만 적재합니다. 필요하지 않은 부분은 디스크의 스왑 영역에 저장하고, 필요할 때 다시 물리 메모리에 적재할 수 있습니다. 이러한 기술을 가상 메모리 기술이라고 하며, 이를 통해 물리 메모리보다 큰 프로세스를 실행할 수 있습니다.

## 페이지 폴트를 처리하는 과정을 설명해 보세요.

CPU의 페이지 폴트 처리 과정은 CPU가 기존의 작업 내역을 백업하고, 페이지 폴트 처리 루틴을 실행합니다. 페이지 처리 루틴은 메모리로 원하는 페이지를 가져와 유효 비트를 1로 변경해 주는 작업을 말합니다. 이렇게 페이지 폴트를 처리하면 CPU가 해당 페이지에 접근할 수 있게 됩니다.

## 파일 디스크립터는 무엇을 식별하는 정보인가요?

파일 디스크립터는 운영체제에서 파일을 식별하기 위한 저수준 정보입니다. 리눅스를 비롯한 여러 운영체제에서는 입출력장치, IPC(파이프, 소켓) 등도 일종의 파일로 간주해 파일 디스크립터로 식별하고 다룰 수 있습니다. 또한 파일 디스크립터는 파일뿐만 아니라 표준 입출력(0), 표준 출력(1), 표준 에러(2)와 같은 입출력 스트림도 식별할 수 있습니다.

## EXT4 파일 시스템에서 디렉터리 내 파일의 데이터를 찾는 과정을 설명해 보세요.

파일이 속한 디렉터리에서 파일 이름에 해당하는 디렉터리 엔트리를 찾고, 해당 파일의 아이노드 번호를 얻습니다. 이렇게 얻은 아이노드 번호를 이용하여 아이노드 테이블에서 해당 아이노드를 찾습니다. 아이노드는 파일의 속성과 데이터가 저장된 위치를 포함하고 있으므로 아이노드를 통해 실제 파일 데이터가 저장된 위치에 접근할 수 있습니다.

## 아이노드란 무엇이며, 아이노드에는 어떤 정보를 저장하는지 설명해 보세요.

아이노드는 파일이 저장된 위치와 속성을 비롯해, 사실상 (파일의 이름을 제외한)파일의 모든 것이 담겨 있는 색인 블록입니다.

## 공장 초기화된 보조기억장치가 있다고 가정해 보세요. 이 때 파일 시스템을 만들고, 텍스트 파일을 저장하기까지의 과정을 설명해 보세요.

파티션을 생성하고 포매팅하여 파일 시스템을 만듭니다. 파일 시스템을 마운트한 뒤, 파일 탐색기나 터미널을 통해 텍스트 파일을 생성하고 저장하면 됩니다.

## 메모리 누수는 무엇이며, 어떻게 해결할 수 있는지 설명해 보세요.

메모리 누수는 프로그램이 할당받은 메모리를 해제하지 않아 메모리가 지속적으로 점유되는 현상을 말합니다. 메모리 누수 문제를 해결하기 위해서는 메모리를 사용한 후 명시적으로 해제하거나 프로그래밍 언어의 가비지 컬렉션을 활용해 정리해야 합니다.

## 스레드를 생성하고 실행할 때 사용하는 join에 대해 설명해 보세요.

join은 생성된 스레드의 실행이 완료될 때까지 기다리게 하는 메서드를 말합니다. 생성된 스레드의 실행이 종료되기도 전에 해당 스레드를 생성한 스레드가 종료되거나 다음 작업을 수행하는 것을 방지할 수 있습니다.

## 동일한 코드를 여러 프로세스로 동시에 실행하는 것과 여러 스레드로 프로세스를 실행하는 것에는 어떤 차이가 있나요?

차이점은 자원 공유 여부에 있습니다. 동일한 코드를 여러 프로세스에서 동시에 실행하는 경우, 기본적으로 각 프로세스는 독립적으로 실행되며 메모리, 파일 등의 자원을 공유하지 않습니다. 반면, 여러 스레드로 프로세스를 실행하는 경우, 동일한 프로세스 내에서 실행되며 자원을 공유합니다. 따라서 스레드 간에는 통신과 협력이 쉽지만, 한 스레드의 문제가 전체 프로세스에 영향을 줄 수 있습니다. 반면, 프로세스는 스레드와 달리 서로 독립적이기 때문에 한 프로세스의 문제가 다른 프로세스에 미치는 영향이 적습니다.

## 응용 프로그램이 새로운 파일을 만들고, "hello"라는 문자열을 입력한 뒤에 저장했습니다. 이 과정에서 컴퓨터 내부(커널)에서는 어떤 일이 발생하는지 설명해 보세요.

먼저, 응용 프로그램이 `open()` 시스템 콜을 통해 운영체제에 파일을 생성하도록 요청합니다. 이 때 CPU가 사용자 모드에서 커널 모드로 전환되어 운영체제가 커널 공간에서 파일 생성 코드를 실행하고, 파일 시스템에 접근해 새로운 파일을 생성합니다. 파일이 생성되면 응용 프로그램은 `write()` 시스템 콜을 사용하여 생성된 파일에 "hello" 문자열을 씁니다. 이 과정에서도 CPU는 커널 모드로 전환되어 실행됩니다. 문자열이 성공적으로 쓰이면 `close()` 시스템 콜을 호출하여 파일을 닫습니다. 작업이 완료되면 사용자 모드로 전환됩니다.

## 교착 상태가 무엇인지, 왜 발생하는지 설명해 보세요.

교착 상태는 2개 이상의 프로세스가 서로 상대방의 자원을 기다리며 무한정 대기하는 상황을 말합니다. 이는 네 가지 조건이 충족될 때 발생할 수 있습니다. 첫째, 자원이 상호 배제되어 한 번에 하나의 프로세스만 사용할 수 있는 경우. 둘째, 이미 자원을 점유한 프로세스가 다른 자원을 기다리는 경우. 셋째, 자원이 비선점되어 다른 프로세스가 강제로 자원을 빼앗지 못하는 경우. 넷째, 프로세스들이 원형으로 자원을 대기하는 경우입니다. 이러한 조건들이 동시에 충족될 때 교착 상태가 발생할 수 있습니다.

## 블로킹 입출력과 논블로킹 입출력의 차이점에 대해 설명해 보세요.

블로킹 입출력과 논블로킹 입출력의 차이는 프로세스가 입출력 작업을 수행할 때 대기하는지의 여부에 있습니다. 블로킹 입출력에서 프로세스가 입출력 작업을 시작하면 해당 작업이 완료될 때까지 대기하는 반면, 논블로킹 입출력에서는 프로세스가 입출력 작업을 시작한 후, 작업이 완료되기를 기다리지 않고 곧바로 다음 명령을 수행합니다.

## 디버깅할 때 주로 볼 수 있는 주소는 실제 물리 메모리의 주소일까요?

디버깅할 때 주로 볼 수 있는 주소는 실제 메모리의 물리 주소가 아니라 논리 주소(가상 메모리 주소)입니다. 프로세스를 실행하는 CPU나 메모리에 적재된 프로세스 입장에서 메모리 내의 물리 주소를 모두 알기는 어렵기 때문에 프로세스마다 부여되는 논리 주소(가상 주소)를 활용합니다. 따라서 디버깅할 때의 메모리 주소는 프로세스의 가상 주소 공간 내에서의 주소에 해당합니다. 이 가상 주소(논리 주소)는 CPU와 메모리 사이에 위치하는 MMU에 의해 물리 주소로 변환됩니다.

## 메모리가 부족하면 어떤 현상이 발생할 수 있는지 설명해 보세요.

메모리가 부족하면 운영체제는 부족한 메모리를 보완하기 위해 디스크에 메모리 페이지를 저장하고, 필요할 때 다시 불러오는 과정인 스와핑을 사용하게 됩니다. 이 작업이 과도하게 이루어질 경우 스래싱이라는 현상을 초래하며, 시스템이 지속적으로 디스크 I/O에만 몰두하게 되어 실질적인 작업 처리가 거의 이루어지지 않게 됩니다.

## 소스 코드를 실행했더니 'Segmentation fault(core dumped)'라는 메시지와 함께 코드가 작동하지 않습니다. 어떻게 해야 할까요?

생성된 코어 덤프 파일에 비정상 종료 당시의 메모리 상태나 비정상 종료 원인을 유추할 정보가 명시되어 있을 것입니다. 이 코어 덤프 파일을 분석하여 문제의 원인을 파악해야 합니다. 가령 코어 덤프 파일에 스택 트레이스가 포함되어 있을 경우, 문제가 발생한 순간의 함수 호출 관계로 문제 발생 지점을 진단할 수 있습니다.

## 프로세스의 페이지 테이블이 모두 메모리에 적재될 경우에 발생할 수 있는 문제점과 해결 방안을 설명해 보세요.

크게 두 가지 문제 상황이 발생할 수 있습니다. 먼저, 메모리 접근 횟수가 많아져 성능이 저하됩니다. 페이지 테이블 접근과 실제 데이터 접근으로 인해 메모리 접근이 두 배로 늘어나기 때문입니다. 또 페이지 테이블이 차지하는 메모리 용량이 커져 비효율적입니다. 이는 TLB를 사용해 페이지 테이블의 일부를 캐싱하거나, 계층적 페이징 기법을 사용해 페이지 테이블을 나누어 관리함으로써 메모리 접근 횟수와 메모리 사용량을 줄일 수 있습니다.

## 가상 머신과 컨테이너의 차이점에 대해 설명해 보세요.

가상 머신은 하이퍼바이저를 통해 물리 하드웨어 위에서 여러 운영체제를 독립적으로 실행합니다. 각 가상 머신은 전체 운영체제와 가상 하드웨어를 포함하기 때문에 상대적으로 무겁습니다. 반면, 컨테이너는 기본적으로 커널을 공유하고 실행하고자 하는 특정 애플리케이션만을 위한 격리성을 제공하기 때문에 상대적으로 가볍고 빠릅니다.

# CHAPTER 04 - 자료구조

## 다음 두 코드는 모두 정수형 리스트 `arr`을 인자로 전달받아 같은 작업을 수행하는 함수입니다. 두 코드 중 더 효율적이라고 판단하는 코드를 고르고, 그 이유를 설명해 보세요.

```python
def first(arr: list[int]) -> list[int]:
    n = len(arr)
    # 배열의 모든 요소를 순회합니다
    for i in range(n):
        # 현재 위치에서 인접한 요소들을 비교합니다
        for j in range(0, n-i-1):
            # 만약 앞의 요소가 뒤의 요소보다 크면 두 요소를 교환합니다.
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
```

```python
def second(arr: list[int]) -> list[int]:
    n = len(arr)
    # 배열의 모든 요소를 순회합니다
    for i in range(n):
        for j in range(i+1, n):
            for k in range(j+1, n):
                # 세 개의 요소를 비교해 필요하면 교환합니다.
                if arr[i] > arr[j]:
                    arr[i], arr[j] = arr[j], arr[i]
                if arr[j] > arr[k]:
                    arr[j], arr[k] = arr[k], arr[j]
                if arr[i] > arr[j]:
                    arr[i], arr[j] = arr[j], arr[i]
    return arr
```

첫 번째 함수인 `first`의 시간 복잡도는 O(n^2)입니다. 그리구 두 번째 함수인 `second`의 시간 복잡도는 O(n^3)입니다. 최대 n번의 연산이 필요한 반복문 3개가 겹쳐 있기 때문입니다. 따라서 `first`의 코드가 더 효율적으로 실행됩니다.

## 시간 복잡도와 빅 오 표기법의 차이를 설명해 보세요.

시간 복잡도는 입력의 크기에 따른 프로그램의 실행 시간 관계를 나타냅니다. 실행 시간은 연산 횟수에 비례하므로 입력의 크기에 따른 프로그램의 연산 횟수로 간주되기도 합니다. 빅 오 표기법은 함수의 점근적 상한을 나타내는데, 시간 복잡도를 표현하기 위해 자주 사용됩니다. 시간 복잡도를 표현하기 위해 빅 오 표기법이 사용된다면 입력에 따른 실행 시간의 점근적 상항을 의미하는 것입니다.

## 인코딩된 값과 해시 값의 차이를 설명해 보세요.

인코딩은 데이터를 다른 방식으로 표현하기 위해 변환하는 것입니다. 인코딩된 값은 디코딩을 거쳐 다시 변환될 수 있습니다. 예를 들어 base64와 아스키 인코딩은 모두 컴퓨터가 이해하는 코드의 형식으로 변환될 수 있고, 그렇게 변환된 코드는 사람이 이해할 수 있는 데이터의 형태로 다시 디코딩될 수 있습니다.

반면, 해시 값은 해시 함수를 사용하여 고정 길이인 임의의 값으로 데이터를 변환한 결과를 말합니다. 해시 함수는 인코딩과는 달리 단방향 함수이기 때문에 데이터를 다시 변환할 수 없습니다. 또한 해시 함수는 임의 길이의 데이터를 입력받아 고정된 길이의 해시 값을 출력하고, 입력값이 조금이라도 달라지면 해시 값도 완전히 다른 값으로 변경됩니다.

따라서 인코딩된 값은 주로 데이터를 다양하게 표현하기 위해 사용하고, 해시 값은 주로 데이터의 무결성을 검증하거나 데이터를 빠르게 검색하기 위해 사용합니다.

## 스택을 배열로 구현해 보세요(push와 pop 연산은 반드시 구현해야 합니다).

다음과 같은 파이썬 소스 코드를 작성해 제출합니다.

```python
class MyStack[T]:
    def __init__(self):
        self._items: list[T] = []

    def push(self, item: T):
        self._items.append(item)

    def pop(self) -> T | None:
        if self.is_empty():
            return None
        item = self.items[-1]
        del self.items[-1]
        return item

    def is_empty(self) -> bool:
        return len(self._items) == 0


def usage():
    my_stack = MyStack[str]()
    my_stack.push("a")
    my_stack.push("b")
    my_stack.push("c")

    print(my_stack.pop())  # c
    print(my_stack.pop())  # b
    print(my_stack.pop())  # a
```

## 큐를 배열로 구현해 보세요(인큐와 디큐 연산은 반드시 구현해야 합니다).

다음과 같은 파이썬 소스 코드를 작성해 제출합니다.

```python
class MyQueue[T]:
    def __init__(self):
        self._items: list[T] = []

    def enqueue(self, item: T):
        self._items.append(item)

    def dequeue(self) -> T | None:
        if self.is_empty():
            return None
        item = self._items[0]
        del self._items[0]
        return item

    def is_empty(self) -> bool:
        return len(self.items) == 0


def usage():
    my_queue = MyQueue[str]()
    my_queue.push("a")
    my_queue.push("b")
    my_queue.push("c")

    print(my_queue.pop())  # a
    print(my_queue.pop())  # b
    print(my_queue.pop())  # c
```

## 다음 그림의 자료구조가 무엇인지 설명하고, 간단한 코드로 구현해 보세요.

```
    a
   / \
  b   c
```

제시된 자료구조는 트리이며, 그 중에서도 이진 트리에 해당합니다. 이진 트리는 각각의 노드가 최대 2개의 자식을 가질 수 있는 트리의 일종입니다. 따라서 다음과 같이 값, 왼쪽 자식 노드, 오른쪽 자식 노드를 표현하는 트리 노드로 구현할 수 있습니다.

```python
class TreeNode[T]:
    def __init__(self, value: T):
        self.value = value
        self.left: TreeNode[T] | None = None
        self.right: TreeNode[T] | None = None


def usage():
    # 루트 노드 생성
    root = TreeNode[str]("a")
    # 왼쪽, 오른쪽 자식 노드 생성
    root.left = TreeNode[str]("b")
    root.right = TreeNode[str]("c")
```

## 직전 문제에서 구현한 자료구조의 모든 노드를 중외 순회하는 코드를 구현해 보세요. 어떤 순서로 방문하게 되나요?

다음과 같이 직전 질문에서 작성한 코드 하단에 코드를 추가합니다. 중위 순회는 '왼쪽 서브트리 => 루트 노드 => 오른쪽 서브트리'의 순으로 모든 트리 노드를 방문하는 것을 의미합니다. 따라서 'b => a => c' 순으로 순회하게 됩니다.

```python
class TreeNode[T]:
    def __init__(self, value: T):
        self.value = value
        self.left: TreeNode[T] | None = None
        self.right: TreeNode[T] | None = None


def inorder_traversal[T](node: TreeNode[T]):
    if node is None:
        return
    # 왼쪽 서브트리를 먼저 방문
    inorder_traversal(node.left)
    # 현재 노드 방문
    print(node.value)
    # 오른쪽 서브트리 방문
    inorder_traversal(node.right)


def usage():
    # 루트 노드 생성
    root = TreeNode[str]("a")
    # 왼쪽, 오른쪽 자식 노드 생성
    root.left = TreeNode[str]("b")
    root.right = TreeNode[str]("c")
    # 중위 순회
    inorder_traversal(root)
```

## 해시 충돌이 무엇이며, 어떻게 해시 충돌을 해결할 수 있는지 설명해 보세요.

해시 충돌이란 서로 다른 키에 대해 같은 해시 값이 대응되는 상황을 의미합니다. 해시 충돌은 체이닝과 개방 주소법 등으로 해결할 수 있습니다. 체이닝은 충돌이 발생한 데이터를 연결 리스트로 추가하는 충돌 해결 방식이고, 개방 주소법은 충돌이 발생한 공간이 아닌 다른 공간을 조사하여 데이터를 저장하는 충돌 해결 방식입니다.

## 해시 테이블의 장점과 단점을 설명해 보세요.

해시 테이블의 장점은 데이터 검색 성능이 빠르다는 것입니다. 해시 테이블에 대한 키가 주어졌다면 해시 테이블의 검색 성능은 O(1)로 매우 빠릅니다. 그러나 데이터가 저장될 공간을 미리 확보해 두어야 하므로 메모리 공간이 많이 소요된다는 점이 단점입니다.

## 배열 대신 연결 리스트를 사용하는 것이 프로그램의 성능에 유리한 경우가 있나요? 만약 그렇다면, 그 이유는 무엇인가요?

배열과는 달리 연결 리스트를 구성하는 모든 노드는 반드시 메모리 내에 순차적으로 저장되어 있을 필요가 없습니다. 따라서 연속적으로 구성되어 있는 데이터를 불연속적으로 저장할 때 유용하게 사용될 수 있고, 배열에 비해 삽입 및 삭제 성능에서 높은 성능을 보입니다.

## 우선순위 큐는 어떻게 구현할 수 있는지 설명해 보세요.

우선순위 큐는 힙 자료구조로 구현됩니다. 힙은 주로 최댓갑과 최솟값을 빠르게 찾는 용도로 사용되는 완전 이진 트리의 일종입니다. 우선순위 큐는 FIFO가 아닌 우선순위가 높은 데이터 순으로 처리하기 때문에, 우선순위가 가장 높은 노드를 루트 노드로 삼는 힙으로 구현하기에 용이합니다.

## 깊이 우선 탐색과 너비 우선 탐색의 차이를 설명해 보세요.

깊이 우선 탐색과 너비 우선 탐색은 그래프를 탐색하는 기본적인 방법입니다. 깊이 우선 탐색은 그래프에서 더 이상 방문 가능한 정점이 없을 때까지, 최대한 깊은 자식 노드까지 탐색하기를 반복하는 탐색 방법이고, 너비 우선 탐색은 인접한 모든 정점들을 방문하고, 방문한 정점들과 연결된 모든 정점들을 방문하기를 반복하는 탐색 방법입니다.

## RB 트리란 무엇이며, 왜 RB 트리를 사용하는지 설명해 보세요.

RB 트리는 이진 탐색 트리의 편향을 방지하기 위해 사용하는 자가 균형 이진 트리의 일종입니다. 이진 탐색 트리는 연산의 순서에 따라 편향된 트리가 될 수 있는데, 편향이 발생할 경우 탐색 속도가 O(n)으로 저하될 수 있습니다. RB 트리는 이를 방지하기 위해 모든 노드를 빨간색, 혹은 검은색으로 간주하고, 노드에 색을 칠하는 규칙과 노드에 칠해진 색을 기준으로 왼쪽 서브트리와 오른쪽 서브트리의 높이 균형을 맞춥니다.

## B 트리란 무엇이며, 왜 B 트리를 사용하는지 설명해 보세요.

B 트리는 여러 자식 노드를 가질 수 있는 다진 탐색 트리의 일종으로, 파일 시스템이나 데이터베이스와 같은 대용량 입출력 작업이 필요한 상황에서 주로 사용합니다.

## 다음 그림의 자료구조가 무엇인지, 어떻게 코드로 구현이 가능한지 설명해 보세요.

제시된 자료구조는 정점과 그 정점들을 연결하는 간선으로 이루어진 그래프 자료구조입니다. 이는 이차원 행렬(이차원 리스트)이나 연결 리스트를 기반으로 구현이 가능합니다.

# CHAPTER 05 - 네트워크

## 브로드캐스트가 무엇이며, 언제 사용하는지 설명해 보세요.

브로드캐스트란 네트워크 내 모든 호스트에게 패킷을 전송하는 전송 방식을 말합니다. 브로드캐스트가 사용되는 대표적인 상황에는 ARP request를 보내는 상황이 있습니다.

## 캡슐화가 무엇인지 설명해 보세요.

네트워크 송신 과정에서 네트워크 참조 모델의 상위 계층 패킷은 하위 계층의 트레일러가 되어 헤더가 덧붙는 과정이 반복됩니다. 네트워크를 통한 송신 과정에서 여러 프로토콜 헤더가 덧붙는 이 과정을 캡슐화라고 합니다. 이 때 덧붙은 헤더는 수신지에서 역캡슐화를 거쳐 제거됩니다.

## MAC 주소와 IP 주소가 각각 무엇인지, 왜 두 주소를 함꼐 사용하는지 설명해 보세요.

MAC 주소는 네트워크 인터페이스에 할당되는 물리적 주소로, 로컬 네트워크 내에서 장치를 식별하는 데 사용합니다. 그리고 모든 IP 주소는 네트워크 간 통신에서 호스트를 식별하는 논리적 주소입니다. 한 호스트가 모든 네트워크, 모든 호스트의 MAC 주소를 기억하기 어렵고, MAC 주소만으로는 네트워크 간의 이동 경로 파악, 즉 라우팅이 불가능하기 때문에 IP 주소도 함께 사용하는 것입니다.

## 서브네팅을 하는 이유를 설명해 보세요.

서브네팅은 IP 주소를 토대로 네트워크를 더 작은 서브네트워크로 나누기 위해 사용합니다. 서브네팅을 통해 IP 주소와 네트워크를 효율적으로 구획하고 관리할 수 있습니다.

## NAT에 대해 설명해 보세요.

NAT는 IP 주소를 변환하는 기술로, 네트워크 내부에서 사용하는 사설 IP 주소와 네트워크 외부에서 사용하는 공인 IP 주소를 변환하는 데 주로 사용됩니다. 오늘날 대중적으로 활용되고 있는 NAT는 변환할 IP 주소 쌍과 포트 번호를 함께 기록하고 변환함으로써 하나의 공인 IP 주소를 여러 사설 IP 주소가 공유할 수 있도록 합니다.

## TCP와 UDP의 차이점이 무엇인지, 두 방식을 사용하는 경우가 어떻게 다른지 설명해 보세요.

TCP와 UDP의 차이점은 신뢰성과 연결 방식에 있습니다.

TCP는 신뢰할 수 있는 연결형 프로토콜로, 데이터를 전송하기 전에 연결을 수립하고 상태 관리, 흐름 제어, 오류 제어, 혼잡 제어 등의 기능을 통해 데이터의 신뢰성과 순서를 보장합니다.

반면, UDP는 신뢰할 수 없는 비연결형 프로토콜로, 연결 수립 과정 없이 빠르게 데이터를 전송할 수 있지만, 데이터의 신뢰성과 순서를 보장하지는 않습니다.

따라서 데이터 유실 없이 안정적인 통신이 필요하다면 TCP를 사용하고, 빠른 속도가 필요하지만 약간의 데이터 손실이 허용되는 경우에는 UDP를 사용하는 것이 적합합니다.

## TCP의 연결 수립 과정을 설명해 보세요.

TCP는 쓰리 웨이 핸드셰이크로 연결 수립 과정이 이루어집니다. 먼저, 클라이언트가 서버에 SYN 패킷을 보내 연결을 요청하면, 서버는 SYN 패킷을 받고 SYN-ACK 패킷으로 응답하여 연결 요청을 승인합니다. 다시 서버의 응답을 받은 클라이언트가 ACK 패킷을 성공적으로 전송하면 클라이언트와 서버 간 연결이 수립됩니다.

## 포트 번호란 무엇이며, 왜 포트 번호가 존재해야 하는지 설명해 보세요.

포트 번호는 컴퓨터 네트워크에서 특정 프로세스를 식별하기 위해 사용하는 수입니다. IP 주소가 네트워크 상의 특정 장치를 식별하는 역할이라면, 포트 번호는 그 장치 내에서 실행 중인 특정 프로세스를 식별하는 역할을 합니다. 포트 번호 없이 IP 주소만으로는 패킷을 최종적으로 주고받을 프로세스를 식별할 수 없기 때문에 포트 번호를 사용합니다.

## HTTP가 스테이트풀한지, 스테이트리스한지에 대해 그 이유와 함께 설명해 보세요.

HTTP는 스테이트리스 프로토콜입니다. 즉, 서버가 클라이언트의 상태를 기억하지 않기 때문에 클라이언트의 모든 HTTP 요청이 독립적으로 처리되며, 각 요청은 이전 요청과 무관하게 다뤄집니다. HTTP가 스테이트리스한 이유는 서버가 클라이언트 다수의 상태를 유지하는 부담을 덜기 위합입니다. 클라이언트의 상태를 유지하려면 서버 간의 상태 정보를 공유해야 하므로 복잡하고 번거롭습니다. 또한 스테이트리스한 특성은 서버를 쉽게 추가하거나 대체할 수 있어 확장성과 견고함을 높일 수도 있습니다.

## 웹 브라우저 상에 'https://www.google.com'을 입력해 웹사이트가 뜨기까지의 과정을 설명해 보세요.

가장 먼저 로컬 DNS 서버에 'www.google.com'에 해당하는 IP 주소가 캐시되어 있는지를 확인합니다. 만약 로컬 DNS 서버가 해당 IP 주소를 저장하고 있다면 해당 IP 주소를 응답하고, 저장하고 있지 않다면 루트 DNS 서버부터 'com' 최상위 도메인(TLD) 서버, 'google' 도메인 서버 등 도메인 네임을 순차적으로 질의하여 IP 주소를 얻어 냅니다.

그리고 클라이언트가 IP 주소를 알게 되면 해당 IP 주소로 TCP 연결을 설정합니다. 이 과정에서 TCP의 쓰리 웨이 핸드셰이크가 수행됩니다. 클라이언트가 서버에 SYN 패킷을 보내고, 서버가 SYN-ACK 패킷으로 응답하면 다시 클라이언트가 ACK 패킷을 보내 연결을 확립합니다.

TCP 연결이 설정되면 HTTP 요청을 보냅니다. HTTPS의 경우 SSL/TLS 핸드셰이크가 추가로 수행되어 보안 연결을 설정합니다. 이후 클라이언트는 GET 요청을 통해 'www.google.com'의 리소스를 요청하고, 요청을 받은 서버는 필요한 데이터를 준비하여 HTTP 응답으로 보냅니다. 이 HTTP 응답에는 요청한 웹 페이지의 HTML 문서가 포함되어 있습니다.

## 배포된 웹사이트의 주소가 '1.2.3.4'이고, 'example.com'이라는 도메인 네임을 구입했다고 가정해 보겠습니다. 이 때 구입한 도메인 네임 'www.example.com'을 웹사이트에 연동하는 과정을 설명해 보세요.

도메인 네임을 제공하는 DNS 서비스 업체의 네임 서버에 접속하여 DNS 자원 레코드를 추가하거나 편집해야 합니다. 레코드 타입 A로 도메인 네임 'www.example.com'을 서버의 IP 주소 '1.2.3.4'에 대응시키면 도메인 네임 'www.example.com'을 '1.2.3.4'로 변환할 수 있습니다.

## HTTP가 스테이트리스하다면 [오늘 하루 그만보기]와 같은 기능은 어떻게 구현할 수 있을까요?

[오늘 하루 그만보기] 기능은 쿠키를 사용해 구현할 수 있습니다. 쿠키는 클라이언트의 상태를 유지하지 않는 스테이트리스 프로토콜의 한계를 보완하는 수단입니다.

## HTTP의 킵 얼라이브란 무엇인가요?

HTTP의 킵 얼라이브는 지속 연결, 즉 클라이언트와 서버 간의 연결을 지속적으로 유지하여 같은 연결을 통해 여러 요청과 응답을 처리하는 기능입니다. 킵 얼라이브를 사용하면 하나의 연결을 통해 여러 요청-응답을 처리할 수 있습니다.

## HTTP 1.1과 HTTP 2.0의 차이점을 설명해 보세요.

HTTP 2.0은 HTTP 1.1의 데이터 송수신 방식과 성능을 개선한 버전입니다. 지속 연결을 처음 공식적으로 지원한 HTTP 1.1은 평문으로 메시지를 주고받는 반면, HTTP 2.0은 바이너리 데이터를 기반으로 송수신하고, 헤더 압축과 서버 푸시 기능을 제공하여 성능을 향상시켰습니다. 또한 HTTP 2.0은 HTTP 멀티플렉싱을 통해 여러 요청을 병렬로 처리하여 HOL 블로킹 문제를 완화했습니다.

## HTTP 메서드인 GET과 POST의 차이를 예시와 함께 설명해 보세요.

서버에서 자원의 표현을 조회하는 데 사용되는 GET 메서드는 웹 페이지를 요청할 때 주로 사용합니다. 요청한 자원의 URL을 통해 필요한 정보를 명시하고, 서버가 해당 자원의 내용을 응답으로 반환합니다. 반면, POST 메서드는 서버에 특정 작업을 처리하도록 요청하는 메서드입니다. POST 요청의 경우 메시지 본문이 사용되는 경우가 많지만, GET 요청의 경우에는 메시지 본문이 잘 사용되지 않습니다.

# HTTP 메서드인 PUT과 PATCH의 차이를 예시와 함께 설명해 보세요.

서버의 자원을 완전히 대체하는 데 사용하는 PUT 메서드는 클라이언트가 보낸 데이터를 기반으로 서버의 기존 자원을 전체적으로 교체하는 메서드입니다. 즉, PUT 요청은 자원의 내용을 덮어쓰기하는 메서드인 반면, PATCH 메서드는 서버 자원의 일부만 수정하는 데 사용하는 메서드로, 자원을 부분적으로 수정합니다.

## 리다이렉션의 정확한 의미를 설명해 보세요.

리다이렉션은 웹 서버가 클라이언트에게 요청한 자원이 다른 위치로 이동했음을 알리고, 해당 위치로 클라이언트를 자동으로 이동시키는 동작을 의미합니다. 웹 페이지나 리소스의 URL이 변경되었을 경우, 리다이렉션을 통해 클라이언트가 올바른 경로로 요청을 보낼 수 있습니다.

## HTTP 요청 메시지를 보낸 클라이언트들이 이전에 접속한 URL을 알고 싶을 때는 어떻게 해야 할까요?

`Referer` 헤더를 확인하면 됩니다. `Referer` 헤더에는 클라이언트가 HTTP 요청 메시지를 보낼 때 머물렀던 URL이 명시되어 있어 이전에 접속한 URL을 확인할 수 있습니다.

## HTTP 요청 메시지를 보낸 클라이언트들의 접속 정보를 알고 싶을 때는 어떻게 해야 할까요?

`User-Agent` 헤더를 확인하면 됩니다. `User-Agent` 헤더에는 클라이언트가 사용한 브라우저의 종류와 운영체제, 아키텍처 정보, 렌더링 엔진의 종류 등 프로그램 관련 정보가 명시되어 있습니다.

## 같은 URL에 접속해도 어떤 환경에서는 영어 페이지가, 어떤 환경에서는 한국어 페이지가 응답되는 이유는 무엇인가요?

콘텐츠 협상이라는 기능 때문입니다. 콘텐츠 협상이란 같은 자원에 대한 다양한 표현 중 클라이언트가 가장 선호하는 자원의 표현을 제공하는 기능입니다. 클라이언트는 요청 메시지의 헤더를 통해 선호하는 언어를 서버에 알릴 수 있고, 서버는 이를 보고 클라이언트가 선호하는 언어로 응답할 수 있습니다.

## HTTP 캐시가 오래될 경우 원본 데이터와의 차이가 발생할 수 있습니다. 이 문제를 해결하는 방법을 설명해 보세요.

캐시된 데이터와 원본 데이터가 불일치할 경우, 클라이언트는 `If-Modified-Since` 헤더나 `If-None-Match` 헤더를 사용해 서버에 원본 데이터의 변경 여부를 확인할 수 있습니다. 이 때 `If-Modified-Since` 헤더는 특정 날짜 이후의 변경 여부를 확인하고, `If-None-Match` 헤더는 자원의 버전 식별자인 `Etag` 값을 사용해 변경 여부를 확인합니다. 서버는 버전 변경이 없으면 304 상태 코드로 알리고, 변경이 있으면 새로운 자원을 반환합니다.

## HTTPS의 동작에 대해 HTTP와 비교하여 설명해 보세요.

HTTP와 HTTPS의 차이는 HTTPS가 TLS를 통해 보안을 추가한 프로토콜이라는 점에 있습니다. 그렇기 때문에 HTTPS의 연결 수립 과정에는 TCP 핸드셰이크 이후 TLS 핸드셰이크 과정이 포함되어 있습니다. 이 과정에서 암호화 통신을 위한 키 교환과 인증서 검증 등이 이루어지고, HTTPS는 암호화 통신을 수행하게 됩니다.

## 포워드 프록시와 리버스 프록시의 차이를 설명해 보세요.

포워드 프록시는 클라이언트와 가까운 위치에 있으며, 클라이언트의 요청을 받아 서버로 전달하는 역할을 합니다. 주로 캐시 저장, 클라이언트 암호화, 접근 제한 등을 통해 클라이언트를 대리합니다. 반면 리버스 프록시는 오리진 서버와 가까운 위치에 있으며, 클라이언트의 요청을 받아 오리진 서버의 응답을 클라이언트에 전달하는 역할을 합니다. 주로 캐시 저장과 로드 밸런싱을 수행합니다.

## 스케일 업과 스케일 아웃의 차이를 설명해 보세요.

스케일 업은 더 높은 사양의 하드웨어를 추가하는 등 더 뛰어난 성능의 자원으로 대체하여 성능을 높이는 방법이고, 스케일 아웃은 여러 시스템을 추가하여 처리 능력을 확장하는 방법입니다.

## 웹 서버와 웹 애플리케이션의 차이점이 무엇인지, 이 둘을 함께 사용하는 이유가 무엇인지 설명해 보세요.

웹 서버는 정적인 콘텐츠를 응답하고, 웹 애플리케이션 서버는 정적인 콘텐츠와 더불어 동적인 컨텐츠도 응답할 수 있습니다. 웹 서버와 웹 애플리케이션을 함께 사용할 경우 정적인 정보는 웹 서버가 응답하고, 동적인 정보는 웹 애플리케이션 서버가 응답함으로써 부하를 분산할 수 있고, 여러 웹 서버 및 웹 애플리케이션을 확장하는 데에 유리합니다.

# CHAPTER 06 - 데이터베이스

## 데이터 저장과 관리가 목적이라면 단순히 파일 시스템을 사용해도 될 것입니다. 그럼 데이터베이스를 사용하는 이유는 무엇일까요?

파일 시스템은 데이터베이스에 비해 데이터의 높은 일관성 및 무결성을 제공하기 어렵기 때문입니다. 파일 시스템에서는 여러 사용자나 프로그램이 동시에 데이터를 사용하는 경우, 레이스 컨디션 등의 문제로 인해 데이터 일관성이 깨지기 쉽습니다. 그리고 데이터 중복 저장으로 인한 저장 공간의 낭비가 발생하거나 데이터를 변경할 때, 연관된 모든 데이터를 수동으로 변경해야 하는 번거로움도 있습니다. 또한 정교한 검색이나 백업 및 복구 기능도 데이터베이스에 비하면 미흡합니다. 따라서 대량의 데이터를 관리하며 여러 사용자에게 제공해야 한다면 파일 시스템보다 데이터베이스를 사용하는 것이 더 효율적입니다.

## 트랜잭션과 ACID가 무엇인지 설명해 보세요.

트랜잭션은 커밋이 발생하는 논리적 단위이며, ACID는 안전한 트랜잭션이 지켜야 할 4가지 특성인 원자성, 일관성, 격리성, 지속성을 의미합니다. 원자성은 트랜잭션의 모든 작업이 성공하거나 실패함을 보장하는 성질을 말하며, 일관성은 트랜잭션 전후에 데이터베이스의 일관된 상태를 유지하는 성질, 격리성은 동시에 수행되는 트랙잭션 간의 간섭이 불가능하도록 보장하는 성질, 지속성은 완료된 트랜잭션의 결과가 영구적으로 반영되는 성질을 말합니다.

## 기본 키가 무엇이며, 어떤 조건을 만족해야 하는지 설명해 보세요.

기본 키는 데이터베이스 테이블에서 각 행을 고유하게 식별하기 위해 선정된 키를 말합니다. 기본 키는 유일성을 갖추어 중복되지 않아야 하고, 반드시 값이 존재해야 하므로 NULL 값을 가질 수 없습니다. 또한 행을 식별하기 위한 최소한의 정보로 구성되어야 합니다.

## 다음에 제시된 테이블이 가지고 있는 문제가 어떤 것인지 설명하고, 그 해결 방법을 제시해 보세요.

| 학생 ID | 과목 코드 | 학생 이름 | 교수 이름 | 과목 이름    |
| ------- | --------- | --------- | --------- | ------------ |
| 1       | CS101     | 김철수    | 이교수    | 데이터베이스 |
| 2       | CS102     | 이영희    | 박교수    | 운영체제     |
| 1       | CS102     | 김철수    | 박교수    | 운영체제     |
| 3       | CS101     | 박민수    | 이교수    | 데이터베이스 |

동일한 과목과 교수 정보가 여러 행에 걸쳐 중복 저장되어 있는 것으로 미루어 보아, 이 테이블은 정규화되어 있지 않습니다. 이 문제를 해겨랗기 위해서는 과목에 대한 정보와 학생에 대한 정보를 분리하여 정규화해야 합니다. 제시된 테이블을 과목 테이블과 학생 테이블로 분리할 수 있습니다. 예를 들어 과목 테이블에는 과목 코드와 과목 이름, 교수 이름을 저장하고, 학생 테이블에는 학생 ID와 과목 코드를 저장하면 됩니다.

## 데이터 관리에 있어 때로는 정규화가 필요하지 않을 때도 있습니다. 정규화가 필요하지 않은 상황은 어떤 상황인가요?

정규화가 항상 최선은 아닙니다. 정규화는 데이터 일관성과 무결성을 높이지만, 테이블을 많이 쪼개다 보면 빈번해진 조인 연산으로 인해 검색의 성능이 저하될 수 있기 때문입니다. 따라서 검색의 성능이 중요한 경우에는 데이터 중복과 연산의 번거로움을 감수하더라도 하나의 테이블로 관리하는 역정규화를 고려할 수 있습니다. 예를 들어 NoSQL 데이터베이스에서는 성능 최적화를 위해 기본적으로 데이터를 정규화하지 않습니다.

## 인덱스란 무엇이며, 인덱스를 통해 어떻게 성능을 향상시킬 수 있는지 설명해 보세요.

인덱스는 특정 테이블 열에 대한 자료구조로, 검색 속도를 향상시키기 위해 사용합니다. 책의 찾아보기와 유사한 개념으로, 인덱스를 통해 원하는 데이터를 빠르게 조회할 수 있습니다. 인덱스를 생성하면 해당 테이블의 열 값들이 정렬된 형태로 저장되므로 테이블 전체를 탐색하지 않고도 빠르게 데이터를 찾을 수 있어 검색 성능이 향상됩니다.

## 인덱스가 오히려 성능을 악화시키는 사례도 있습니다. 이러한 성능 악화는 어떤 상황에서 발생하는지, 그래서 인덱스를 언제, 어떻게 사용해야 하는지에 대해 설명해 보세요.

인덱스를 사용하면 SELECT 연산의 성능은 향상시킬 수 있지만, INSERT나 UPDATE, DELETE 연산에서는 성능을 저하시킬 수 있습니다. 새로운 데이터를 삽입하거나 기존 데이터를 수정/삭제하는 경우에는 인덱스도 함께 갱신해야 하기 때문입니다. 따라서 인덱스는 데이터가 많고 조회가 빈번한 테이블에 사용하며, 중복 데이터가 많지 않은 열이나 JOIN, WHERE, ORDER BY에서 자주 참조되는 열에 생성하는 것이 효율적입니다.

## 인덱스에는 B 트리, 혹은 B 트리의 변형인 자료구조가 사용됩니다. 그 이유를 설명해 보세요.

B 트리 혹은 B+ 트리와 같은 B 트리의 변형은 대용량 데이터에 대한 빠른 탐색에 특화된 자료구조이기 때문입니다. B 트리는 균형 잡힌 트리 구조로서 데이터가 정렬된 상태로 저장되고, 각각의 노드가 여러 개의 자식을 가질 수 있어 탐색을 위한 연산 횟수가 일반적인 트리에 비해 적습니다. 이렇게 원하는 레코드를 빠르게 탐색할 수 있기 때문에 인덱스에서 주로 사용됩니다.

## 참조 무결성 제약 조건에 대해 설명해 보세요.

참조 무결성 제약 조건이란 외래 키를 통해 테이블 간의 참조 관계에서 데이터의 일관성을 유지하기 위한 조건을 말합니다. 외래 키는 테이블의 기본 키와 같은 값을 갖거나 NULL 값을 가져야 합니다.

## INNER 조인과 OUTER 조인의 차이점을 설명명해 보세요.

INNER 조인은 조인 조건을 만족하는 행들만 결과에 포함되며, 공통된 데이터가 있는 경우에만 데이터를 추출합니다. OUTER 조인은 공통된 값이 없는 행도 포함하여 반환합니다. 가령 OUTER 조인의 일종인 LEFT OUTER 조인은 왼쪽 테이블의 모든 행과 오른쪽 테이블의 일치하는 값을 반환하고, 일치하지 않는 경우 NULL을 반환합니다. 또 다른 OUTER 조인의 일종인 RIGHT OUTER 조인은 오른쪽 테이블의 모든 행과 왼쪽 테이블의 일치하는 값을 반환하고, 일치하지 않는 경우 NULL을 반환합니다. FULL OUTER 조인은 양쪽 테이블의 모든 행을 반환하고, 어느 한 쪽에서 일치하는 값이 없는 경우 NULL을 반환합니다.

## 아래 테이블을 토대로 답변하는 질문입니다.

다음은 어떤 기업의 사업부서 및 직원에 대한 정보를 나타내는 테이블입니다. Employees 테이블에는 직원의 ID(EmployeeID)와 이름(FirstName), 성(LastName), 사업부서 ID(DepartmentID), 연봉(Salary)이 저장되어 있고, Departments 테이블에는 사업부서의 ID(DepartmentID)와 부서명(DepartmentName)이 저장되어 있습니다. 두 테이블을 기반으로 관련 질문에 답변해 보세요.

Employees 테이블:

| EmployeeID | FirstName | LastName | DepartmentID | Salary |
| ---------- | --------- | -------- | ------------ | ------ |
| 1          | John      | Doe      | 1            | 50000  |
| 2          | Jane      | Smith    | 2            | 60000  |
| 3          | Bob       | Brown    | 1            | 45000  |
| 4          | Alice     | Davis    | 3            | 70000  |
| 5          | Charlie   | Miller   | 2            | 55000  |

Departments 테이블:

| DepartmentID | DepartmentName |
| ------------ | -------------- |
| 1            | HR             |
| 2            | Finance        |
| 3            | Engineering    |

### 모든 직원의 이름을 조회하는 SQL문을 작성해 보세요.

```sql
SELECT FirstName, LastName
    FROM Employees;
```

### 전 직원의 급여를 10% 인상하는 SQL문을 작성해 보세요.

```sql
UPDATE Employees
    SET Salary = Salary * 1.10;
```

### Employees 테이블의 DepartmentID가 Departments 테이블의 DepartmentID를 참조하는 외래 키를 추가해 보세요. 참조하는 테이블의 레코드가 삭제될 경우에는 참조한 테이블의 레코드가 함께 삭제되어야 하며, 참조하는 테이블의 레코드가 수정될 경우에는 참조한 테이블의 레코드를 NULL로 설정해야 합니다.

```sql
ALTER TABLE Employees
    ADD FOREIGN KEY (DepartementID)
    REFERENCES Departments(DepartmentID)
    ON DELETE CASCADE
    ON UPDATE SET NULL;
```

### Employees 테이블과 Departments 테이블을 INNER 조인하여 모든 직원의 이름과 부서 이름을 조회하는 SQL문을 작성해 보세요.

```sql
SELECT Employees.FirstName, Employees.LastName, Departments.DepartmentName
    FROM Employees
    INNER JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID;
```

### Employees 테이블과 Departments 테이블을 INNER 조인하여 Finance 부서의 직원 이름과 급여를 조회하는 SQL문을 작성해 보세요.

```sql
SELECT Employees.FirstName, Employees.LastName, Employees.Salary
    FROM Employees
    INNER JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID
    WHERE Departments.DepartmentName = 'Finance';
```

## SQL에서 뷰를 사용하는 목적을 설명해 보세요.

뷰는 SQL 쿼리의 단순화 및 재사용성을 위해 사용합니다. 복잡한 쿼리를 자주 실행해야 하는 경우, 뷰를 생성하여 동일한 결과를 간단하게 얻을 수 있습니다. 뷰는 여러 테이블을 조인하거나 복잡한 조건을 포함한 쿼리를 하나로 만들어 반복적인 쿼리 작성을 줄이고자 할 때, 또 특정 사용자에게 테이블의 특정 데이터만을 보여주고자 할 때도 사용할 수 있습니다.

## NoSQL 데이터베이스란 무엇이며, 관계형 데이터베이스와 어떤 차이점이 있는지 설명해 보세요.

관계형 데이터베이스는 테이블 기반의 구조로서 스키마가 고정되어 있는 반면, 비관계형 데이터베이스인 NoSQL 데이터베이스는 데이터의 저장 및 관리를 위해 고정된 스키마가 없고, 수평 확장이 용이한 구조를 가지고 있습니다. NoSQL 데이터베이스는 키-값, 도큐먼트, 칼럼 패밀리, 그래프 등의 다양한 형태로 저장할 수 있습니다.

## 관계형 데이터베이스와 비교해 NoSQL 데이터베이스는 어떤 상황에서 유리한가요? 또 어떤 상황에서 불리한가요?

NoSQL 데이터베이스는 대규모의 비정형 데이터를 처리할 때, 높은 확장성과 빠른 읽기/쓰기 성능이 필요할 때 유리합니다. 그러나 엄격한 트랜잭션 관리나 데이터 일관성 보장, 관계형 데이터 모델링이 필요한 애플리케이션에서는 관계형 데이터베이스가 더 적합하므로 NoSQL 데이터베이스는 불리할 수 있습니다.

## Redis가 캐시 서버로서 동작하는 부차적인 데이터베이스로 유용하게 사용되는 이유는 Redis의 어떤 특성 때문인지 설명해 보세요.

우선 Redis는 인메모리 데이터베이스이기 때문에 디스크 접근 시간을 단축할 수 있습니다. 또한 Redis는 여러 자료구조를 지원하는 키-값 데이터베이스로써, RDBMS보다 정형화되어 있지 않은 데이터에 대한 빠른 입출력이 가능합니다. 따라서 RDBMS 등을 주요 데이터베이스로 삼고, Redis를 캐시 역할을 수행하는 부차적인 데이터베이스로 삼으면 주요 데이터베이스의 입출력 성능을 상당 부분 보강할 수 있습니다.

## 데이터베이스 샤딩이 무엇인지 설명해 보세요.

데이터베이스 샤딩은 샤드라는 단위로 여러 데이터베이스 서버에 걸쳐 테이블을 분할하여 저장하는 기술을 의미합니다. 여러 서버에 분산되어 저장되는 특성 덕분에 데이터베이스에 대한 부하 분산 효과를 얻을 수 있습니다.
