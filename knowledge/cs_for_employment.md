# CHAPTER 02 - 컴퓨터 구조

## RAM과 하드 디스크의 차이를 설명해 보세요.

RAM이 CPU가 실행할 프로그램을 저장하는 부품이라면, 하드 디스크는 전원이 꺼져도 보관할 대상을 저장하는 부품입니다. 휘발성 저장장치인 RAM은 전원이 꺼지면 저장된 내용을 잃지만, 하드 디스크는 비휘발성 저장장치이기 때문에 전원이 꺼져도 저장된 내용을 잃지 않는다는 차이가 있습니다.

## 병렬성과 동시성, 두 개념의 차이를 예시와 함께 설명해 보세요.

병렬성은 작업을 실제로 같은 시각에 동시 처리하는 성질을 의미하고, 동시성은 작업을 동시에 처리하는 것처럼 보이는 성질을 의미합니다. 멀티코어 CPU의 여러 코어가 같은 시각에 명령어를 동시에 처리하는 것이 병렬성의 예시이고, 1코어 1스레드 CPU가 여러 작업을 빠르게 번갈아 가며 처리하는 것이 동시성의 예시입니다.

## CPU가 자발적으로 발생시키는 인터럽트와 CPU가 받아들이는 인터럽트의 차이가 무엇인지 설명해 보세요.

CPU가 자발적으로 발생시키는 인터럽트는 동기적인 인터럽트로, CPU가 프로그래밍 오류와 같은 예외적으로 예상치 못한 상황을 마주쳤을 때 주로 발생하는 인터럽트입니다. 반면, CPU가 받아들이는 인터럽트는 비동기적인 인터럽트로, 주로 입출력장치로부터 받아들이는 하드웨어 인터럽트를 말합니다.

## 다음 소스 코드의 결과는 모두 '3.000...4'입니다. 그 이유를 설명해 보세요.

```python
print(0.1 + 0.2)
```

```java
System.out.println(0.1 + 0.2);
```

```javascript
console.log(0.1 + 0.2);
```

컴퓨터는 내부적으로 부동 소수점 방식을 통해 소수를 표현합니다. 부동 소수점 방식은 2진수로 소수를 표현하는 방법으로, '가수×2^지수'의 형태를 띱니다. 소스 코드에 제시된 '0.1'과 '0.2'는 10진수 소수로, '가수×10^지수'의 형태로 표현할 수 있지만, 이를 부동 소수점 방식의 2진수로 표현하면 무한 소수가 됩니다. 무한 소수에 무한 소수를 더한 결과를 10진수 소수로 표현하다 보니 오차가 발생한 것입니다.

## 다음 소스 코드에는 성능상의 문제가 있습니다. 어떤 문제인지 설명해 보세요.

```java
public class Main {
    public static void main(String[] args) {
        int[][] matrix = new int[20000][20000];

        for (int i = 0; i < 20000; i++) {
            for (int j = 0; j < 20000; j++) {
                matrix[j][i] = 1;
            }
        }
    }
}
```

주어진 소스 코드 중 배열에 접근하는 `matrix[j][i] = 1;` 부분은 캐시 친화적이지 않기 때문에 성능상의 문제가 될 수 있습니다. 배열이 저장된 위치에 순차적으로 접근하지 않기 때문에 성능 저하를 가져오게 됩니다. 이차원 배열이 메모리에 저장된 순서에 따라 접근하도록 코드를 수정하면 프로그램의 속도를 개선할 수 있습니다.

## 장치 드라이버는 왜 설치해야 하나요?

CPU가 장치 컨트롤러를 작동시키기 위한 정보를 알아야 하기 때문입니다. CPU는 장치 드라이버가 설치되어 있지 않으면 해당 입출력장치를 어떻게 작동시켜야 할지, 즉 장치 컨트롤러와 어떻게 정보를 주고받아야 하는지 알 수가 없습니다.

## 파이프라이닝이란 무엇이며, 어떻게 CPU의 성능을 향상시키는지 설명해 보세요.

파이프라이닝이란 명령어 병렬 처리 기법 중 하나로, 하나의 명령어를 처리하는 과정을 비슷한 시간 간격으로 쪼갠 뒤, 쪼개진 각각의 단계에서 동시에 실행 가능한 단계를 겹쳐서 실행해 CPU의 처리 성능을 높입니다.

## GPU와 CPU를 비교하여 설명해 보세요.

GPU는 주로 산술 연산과 같이 단순 연산을 병렬적으로 수행하기 위한 장치이고, CPU는 범용적인 연산을 수행하기 위한 장치입니다. GPU는 병렬 처리를 위한 코어가 수백에서 수천 개까지 포함되어 있지만, CPU처럼 코어마다 복잡한 연산을 지원하지는 않습니다.

## `base64` 인코딩이란 무엇이며, 어디에서 `base64` 인코딩을 사용하는지 설명해 보세요.

`base64` 인코딩은 문자뿐만 아니라 아스키 코드로 표현할 수 없는 이미지 등의 이진 데이터까지 아스키 형태의 문자로 표현하기 위해 사용하는 인코딩 방식입니다. 주로 이메일에서 첨부파일을 전송하거나 웹에서 이미지 및 파일 데이터를 텍스트 형식으로 포함할 때 사용합니다.

## 동일한 소스 코드라 하더라도 애플 M1 컴퓨터에서 컴파일해 만든 실행 파일을 인텔 x86 컴퓨터로 옮겨 실행할 수 없는 이유를 설명해 보세요.

동일한 소스 코드라도 각기 다른 명령어로 변환될 수 있기 때문입니다. 실행 파일은 각각의 컴퓨터가 이해할 수 있는 명령어의 모음이기 때문에 CPU마다 이해하는 명령어의 집합이 다릅니다. 따라서 실행할 수 있는 실행 파일도 달라집니다. 이런 이유로 애플 M1 컴퓨터에서 컴파일해 만든 실행 파일을 인텔 x86 컴퓨터로 옮겨서 실행하면 실행이 되지 않는 것입니다.

## 하드웨어적 스레드와 소프트웨어적 스레드의 차이에 대해 설명해 보세요.

하드웨어 스레드는 하나의 코어가 동시에 처리하는 명령어의 단위를 의미합니다. 논리 프로세서라고도 부릅니다. 소프트웨어 스레드란 하나의 프로그램에서 독립적으로 실행되는 단위를 의미합니다. 따라서 1코어 1스레드 CPU에서도 여러 소프트웨어 스레드를 빠르게 번걸아가며 실행할 수 있습니다.

## 코딩을 하다가 한글이 깨지면 어떻게 대처해야 할까요?

한글이 깨지는 경우는 컴퓨터가 이해할 수 있는 문자의 모음, 문자 집합을 인식하지 못했거나 문자 집합을 코드로 표현하는 인코딩 방법을 인식하지 못한 경우입니다. 따라서 다른 문자 집합을 지원하는 다양한 인코딩 방법을 시도해 봐야 합니다.

## PCIe란 무엇이며, PCIe가 연결 부품의 성능과 어떤 연관이 있는지 설명해 보세요.

PCIe란 대표적인 입출력 버스의 일종으로, 버전에 따라 지원되는 최대 속도(대역폭)
이 다르므로 연결되는 부품의 성능에 영향을 끼칠 수 있습니다. PCIe 3.0의 최대 지원 속도는 PCIe 6.0의 최대 지원 속도에 비해 느리기 때문에 같은 부품이라 하더라도 PCIe 3.0에 연결할 경우 입출력 버스의 최대 지원 속도가 더 느릴 수 있습니다.

## 캐시 미스란 무엇이며, 캐시 미스가 프로그램의 성능에 어떤 영향을 끼치는지 설명해 보세요.

캐시 미스란 캐시에 있을 것이라고 기대했던 데이터가 캐시에 존재하지 않는 상황을 의미합니다. 캐시 미스가 발생하면 캐시를 활용할 수 없고, 메모리와 같이 실제로 데이터가 위치하고 있는 먼 곳까지 접근해야 합니다. 따라서 프로그램의 성능에 악영향을 끼치게 됩니다.

## 유니코드란 무엇인지 설명해 보세요.

여러 국가의 언어나 이모티콘 등을 표현할 수 있는 통일된 문자 집합을 말합니다. 유니코드마다 부여되어 있는 고유한 수, 코드 포인트를 어떻게 코드로 표현하는지에 따라 `utf-8`, `utf-16`, `utf-32` 등 다양한 인코딩 방법으로 구분할 수 있습니다.

# CHAPTER 03 - 운영체제

## 다음 코드에는 문제가 있습니다. 어떤 문제가 있는지 설명해 보세요.

```c
#include <stdio.h>
#include <pthread.h>

int shared_data = 0;  // 공유 데이터

void* increment(void* arg) {
    int i;
    for (i = 0; i < 100000; i++) {
        shared_data++;  // 공유 데이터 증가
    }
    return NULL;
}

void* decrement(void* arg) {
    int i;
    for (i = 0; i < 100000; i++) {
        shared_data--;  // 공유 데이터 감소
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;

    pthread_create(&thread1, NULL, increment, NULL);
    pthread_create(&thread2, NULL, decrement, NULL);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    printf("Final value of shared_data: %d\n", shared_data);

    return 0;
}
```

공유 데이터인 `shared_data`가 두 스레드에서 동시에 수정되는 과정에서 발생할 수 있는 레이스 컨디션 문제가 있습니다. `shared_data++`와 `shared_data--`라는 임계 구역에서의 연산이 하나씩만 수행되지 않기 때문에 데이터의 일관성이 보장되지 않을 수 있습니다.

## 직전 문제에서 제시한 코드의 문제를 해결해 보세요.

문제를 해결하려면 mutex 등을 활용해 공유 자원에 대한 접근을 동기화해야 합니다. 다음과 같은 코드를 추가하면 이계 구역을 보호할 수 있습니다.

```c
#include <stdio.h>
#include <pthread.h>

int shared_data = 0;  // 공유 데이터
pthread_mutex_t mutex;  // 뮤텍스 선언

void* increment(void* arg) {
    int i;
    for (i = 0; i < 100000; i++) {
        pthread_mutex_lock(&mutex);  // 뮤텍스 락 획득
        shared_data++;  // 공유 데이터 증가
        pthread_mutex_unlock(&mutex);  // 뮤텍스 언락
    }
    return NULL;
}

void* decrement(void* arg) {
    int i;
    for (i = 0; i < 100000; i++) {
        pthread_mutex_lock(&mutex);  // 뮤텍스 락 획득
        shared_data--;  // 공유 데이터 감소
        pthread_mutex_unlock(&mutex);  // 뮤텍스 언락
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;

    pthread_mutex_init(&mutex, NULL);  // 뮤텍스 초기화

    pthread_create(&thread1, NULL, increment, NULL);
    pthread_create(&thread2, NULL, decrement, NULL);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    printf("Final value of shared_data: %d\n", shared_data);

    pthread_mutex_destroy(&mutex);  // 뮤텍스 해제

    return 0;
}
```

## 공유 메모리 기반 IPC가 소켓 통신보다 빠른 이유를 설명해 보세요.

공유 메모리는 동일한 메모리 공간에 직접 접근하여 데이터를 주고받고, 마치 자신의 메모리 공간을 읽고 쓰는 것처럼 IPC가 이루어지기 때문에 빠릅니다. 이에 반해 소켓 통신은 주고받는 데이터가 커널을 통하므로 추가적인 오버헤드가 발생할 수 있어, 공유 메모리 기반 IPC보다 다소 느릴 수 있습니다.

## 운영체제가 메모리에 적재되기까지의 과정을 설명해 보세요(부팅의 과정을 설명해 보세요).

컴퓨터 전원이 켜지면 CPU는 ROM에 저장된 BIOS를 실행합니다. BIOS는 하드웨어를 검사하는 POST 수행 후, 하드 디스크의 MBR을 읽어 부트 로더를 로드합니다. 부트 로더가 커널의 위치를 찾아 RAM에 적재함으로써 커널이 메모리에 로드됩니다.

## 운영체제의 커널이 무엇이며, 커널이 왜 존재하는지에 대해 설명해 보세요.

커널은 운영체제의 핵심 부분으로, 컴퓨터 하드웨어와 응용 프로그램 간의 중재자 역할을 합니다. 커널은 프로세스와 스레드가 올바르게 실행되도록 돕고, 이들이 CPU, 메모리, 보조기억장치 등의 하드웨어를 공정하게 할당받아 실행되도록 합니다. 또 커널은 이중 모드를 운영해 사용자 응용 프로그램이 안전하고 효율적으로 시스템 자원을 사용할 수 있도록 합니다.

## 스레드 안전하지 않은 메서드를 동기화하지 않으면 어떤 문제가 생길 수 있나요?

여러 스레드가 동시에 실행될 경우 레이스 컨디션이 발생하여 데이터의 일관성이 깨질 수 있습니다. 따라서 추가적인 동기화 도구를 적용하거나, 스레드 안전한 메서드를 사용해야 합니다.

## 리눅스 운영체제에서 일반적인 사용자 프로세스가 어떻게 CPU를 할당받아 실행되는지 설명해 보세요.

리눅스에서 일반적인 사용자 프로세스는 CFS 스케줄러에 의해 스케줄링됩니다. CFS 스케줄러는 각 프로세스에 CPU의 시간을 공평하게 배분하는 것을 목표로 합니다. 기본적으로 각 프로세스의 가상 실행 시간인 `vruntime`을 유지하며, `vruntime`이 가장 작은 프로세스부터 스케줄링합니다. 프로세스의 `vruntime`은 실제 실행 시간에 프로세스의 우선순위에 따른 가중치를 고려하여 계산되며, 우선순위가 높을수록 `vruntime`의 증가가 느려지기 때문에 우선순위가 높은 프로세스는 더 자주 CPU를 할당받게 됩니다.

## 지나치게 문맥 교환이 반복되면 어떤 문제가 발생할 수 있나요?

빈번한 문맥 교환은 실제 작업보다 문맥 저장과 복구에 CPU 시간을 사용하게 되므로 효율성을 떨어뜨립니다. 또한 캐시 메모리의 데이터를 반복적으로 무효화하게 되므로 캐시 미스율이 증가하고, 캐시 미스와 문맥 교환 오버헤드로 인한 전체 시스템의 처리 속도가 저하될 수 있습니다.

## 4GB보다 큰 크기의 프로그램을 4GB인 물리 메모리로 실행할 수 있을까요? 실행할 수 있다면 어떻게 가능할까요?

가상 메모리 기술을 통해 가능합니다. 운영체제는 프로세스가 필요한 메모리 공간을 가상 주소로 할당하고, 실제 물리 메모리에는 필요한 부분만 적재합니다. 필요하지 않은 부분은 디스크의 스왑 영역에 저장하고, 필요할 때 다시 물리 메모리에 적재할 수 있습니다. 이러한 기술을 가상 메모리 기술이라고 하며, 이를 통해 물리 메모리보다 큰 프로세스를 실행할 수 있습니다.

## 페이지 폴트를 처리하는 과정을 설명해 보세요.

CPU의 페이지 폴트 처리 과정은 CPU가 기존의 작업 내역을 백업하고, 페이지 폴트 처리 루틴을 실행합니다. 페이지 처리 루틴은 메모리로 원하는 페이지를 가져와 유효 비트를 1로 변경해 주는 작업을 말합니다. 이렇게 페이지 폴트를 처리하면 CPU가 해당 페이지에 접근할 수 있게 됩니다.

## 파일 디스크립터는 무엇을 식별하는 정보인가요?

파일 디스크립터는 운영체제에서 파일을 식별하기 위한 저수준 정보입니다. 리눅스를 비롯한 여러 운영체제에서는 입출력장치, IPC(파이프, 소켓) 등도 일종의 파일로 간주해 파일 디스크립터로 식별하고 다룰 수 있습니다. 또한 파일 디스크립터는 파일뿐만 아니라 표준 입출력(0), 표준 출력(1), 표준 에러(2)와 같은 입출력 스트림도 식별할 수 있습니다.
